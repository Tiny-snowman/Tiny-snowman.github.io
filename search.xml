<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>世间所有的相遇，都是久别重逢</title>
    <url>/2021/07/28/trifles/first/</url>
    <content><![CDATA[<h3 id="难言爱恨，事事中庸。"><a href="#难言爱恨，事事中庸。" class="headerlink" title="难言爱恨，事事中庸。"></a><center>难言爱恨，事事中庸。</center></h3><h3 id="回首平生，皆是遗憾。"><a href="#回首平生，皆是遗憾。" class="headerlink" title="回首平生，皆是遗憾。"></a><center>回首平生，皆是遗憾。</center></h3>]]></content>
      <categories>
        <category>trifles</category>
      </categories>
      <tags>
        <tag>trifles</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/06/23/note/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的优点：由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<p>饿汉式</p>
<ul>
<li>坏处：对象加载时间过长</li>
<li>好处：线程安全</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Bank bank1 = Bank.getBank();</span><br><span class="line">        Bank bank2 = Bank.getBank();</span><br><span class="line">        System.out.println(bank1 == bank2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bank&#123;</span><br><span class="line">    private Bank()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static Bank bank = new Bank();</span><br><span class="line">    public static Bank getBank()&#123;</span><br><span class="line">        return bank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>懒汉式:</p>
<ul>
<li>坏处：线程不安全</li>
<li>好处：延迟对象的创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class singleton2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Order&#123;</span><br><span class="line">    private Order()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static Order instance = null;</span><br><span class="line">    public static Order getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Order();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划之经典问题</title>
    <url>/2022/06/01/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i] = 1;</span><br><span class="line">    for(int j = i-1; j; j --)</span><br><span class="line">    &#123;   </span><br><span class="line">        //最长不下降子序列</span><br><span class="line">        if(a[j] &lt;= a[i]</span><br><span class="line">        dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">        //最长不上升子序列</span><br><span class="line">        if(a[j] &gt;= a[i])</span><br><span class="line">        dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分做法（O-nlogn"><a href="#二分做法（O-nlogn" class="headerlink" title="二分做法（O(nlogn))"></a>二分做法（O(nlogn))</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memset(b, 0x3f3f, sizeof b);</span><br><span class="line">memset(c, -0x3f3f, sizeof c);</span><br><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    //在下降的序列中寻找小于arr[i]的数</span><br><span class="line">    *upper_bound(c + 1, c + 1 + n, arr[i], greater&lt;int&gt;()) = arr[i];</span><br><span class="line">    *lower_bound(b + 1, b + 1 + n, arr[i]) = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">//最长下降长度</span><br><span class="line">cout &lt;&lt; lower_bound(c + 1, c + n + 1, c[0], greater&lt;int&gt;()) - c - 1 &lt;&lt; endl;</span><br><span class="line">//最长上升长度</span><br><span class="line">cout &lt;&lt; lower_bound(b + 1, b + 1 + n, b[0]) - b - 1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环</title>
    <url>/2021/07/28/algorithm/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<p><strong>递归方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int ysf(int n, int m, int i)</span><br><span class="line">//有n个人，报道数字k时出局，第i个人出局的编号</span><br><span class="line">&#123;</span><br><span class="line">    if(i == 1) return (m-1+n)%n;</span><br><span class="line">    return (ysf(n-1, m, i-1)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>链表写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">list&lt;int&gt; li;</span><br><span class="line">int cnt, num;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= m; i ++) li.push_back(i);</span><br><span class="line">    list&lt;int&gt; ::iterator it = li.begin();</span><br><span class="line">    int f = 0;</span><br><span class="line">    while(li.size() != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        num ++;</span><br><span class="line">        if(f) it ++;</span><br><span class="line">        f = 1;</span><br><span class="line">        if(it == li.end()) it = li.begin();</span><br><span class="line">        if(num == n)</span><br><span class="line">        &#123;</span><br><span class="line">            it = li.erase(it);</span><br><span class="line">            f = 0;</span><br><span class="line">            num = 0;</span><br><span class="line">            if(it == li.end()) it = li.begin(), f = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    it = li.begin();</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>手写循环链表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	/* data */</span><br><span class="line">	int data;</span><br><span class="line">	struct node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">void ysf(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">	Node *head = NULL, *p = NULL, *r = NULL;</span><br><span class="line">	head = (Node*)malloc(sizeof(Node));</span><br><span class="line">	head-&gt;data = 1;</span><br><span class="line">	head-&gt;next = NULL;</span><br><span class="line">	p = head;</span><br><span class="line">	for(int i = 2; i &lt;= n; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		r = (Node*)malloc(sizeof(Node));</span><br><span class="line">		r-&gt;data = i;</span><br><span class="line">		r-&gt;next = NULL;</span><br><span class="line">		p-&gt;next = r;</span><br><span class="line">		p = r;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = head;</span><br><span class="line">	p = head;</span><br><span class="line">	while(p-&gt;next != p)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i = 1; i &lt; m; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			r = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		r-&gt;next = p-&gt;next;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	ysf(n, m);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
</search>
